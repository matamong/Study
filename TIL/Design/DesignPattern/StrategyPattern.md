# 전략 패턴(Strategy Pattern)

## 전략 패턴이란?
 > **전략 패턴** 이란,<br>
   알고리즘을 정의하고 각각을 캐슐화하여 교환해서 사욜할 수 있도록 만드는 패턴으로 독립적으로 알고리즘을 변경할 수 있다.

정의만 보면 무슨 말인지 모르겠다.<br>
여기서 **`캡슐화`** 를 주목하면서 바로 아래 **전략 패턴 이해하기** 에서 예제를 살펴보자.

<br><br>

## 전략 패턴 이해하기

<br>

### **1 단계 : 날 것의 코드를 먼저 보자.**

```java
public class 예예치킨{
  치킨을튀긴다();
  치킨을양념한다();
  치킨을포장한다();
}
```

여기 예예치킨 객체가 있다. <br>
이 객체는 치킨을 튀기며 양념하고 포장해서 치킨을 만드는 메서드를 가지고 있다. <br>
예예치킨은 이 객체를 중심으로 스노윙예예치킨, 파닭예예치킨 등등을 만드려고 한다. <br>
**상속** 을 이용해서 기존 예예치킨을 확장하는 것이 좋을 것 같아 상속을 이용해서 확장시켜보았다.

```java
class 스노윙예예치킨 extends 예예치킨{
  @override
  치킨을양념한다(){
    System.out.println("스노윙 양념을 친다.");
  }
}

class 파닭예예치킨 extends 예예치킨{
  @override
  치킨을양념한다(){
    System.out.println("파닭 양념을 친다.");
  }
}

```

예예치킨을 상속받은 상태이니 다른 것은 다 구현된 상태이므로 `치킨을 양념한다()` 메서드만 `오버라이드`해주면 아주 간단하게 치킨들을 확장시킬 수 있을 것이다! <br><br>

### **2 단계: 문제에 부딪쳐보자.**

상속을 활용하는 덕분에 자신감에 찬 예예치킨 사장(?)은 이를 활용하여 더욱 과감하게 치킨메뉴를 확장하게 되었다. 순살예예치킨, 마라예예치킨, 양파크림예예치킨, 깐풍예예치킨 등등... 자신있게 상속을 이용해서 많은 치킨들을 만들어냈다. <br>
그런데 여기서 예예치킨은 엄청난 것을 하나 만들어내게 된다. 
<br>
**바로 `구운예예치킨` 과 `삶은예예치킨` 을!!**
<br>
그렇다. 지금까지 치킨을 튀기기만 했던 예예치킨 사장은 이제 치킨을 굽고 삶아서 세상에 내놓고 싶은 것이다! <br>
예예치킨 사장은 상속을 이용해서 단숨에 이 치킨을 만들어보려고 한다. <br>
**그런데** , 상속을 시도하던 예예치킨 사장은 당황하고 만다.

```java
public class 예예치킨{
  치킨을튀긴다();
  치킨을양념한다();
  치킨을포장한다();
}
```
지금까지 계속 상속하여 사용해왔던 예예치킨의 클래스에는 치킨을 튀긴다는 메서드가 들어가있기 때문에 새로 상속받으려는 `구운예예치킨` 과 `삶은예예치킨` 은 어쩔 수 없이 이 메서드를 구현할 수 밖에 없는 것이었다! <br>
물론 `구운예예치킨` 과 `삶은예예치킨` 만을 위하여 상속을 하지 않고 따로 클래스를 만들어도 되겠지만, 그렇게 될 경우 앞으로 새로운 시도를 하는 모든 메뉴의 경우에도 따로 클래스를 만들어야 한다는 문제가 생겼다. **어차피 양념하고 포장하는 메서드는 똑같을 것인데 말이다.** <br> 
그렇다고 아예 `예예치킨` 클래스를 뜯어고치자니 다른 치킨들에게 끼치는 영향이 어마어마하여 건드릴 엄두도 못 내는 상황이다. <br><br>

예예치킨사장은 문제를 다음과 같이 정리했다.
- `예예치킨` 클래스의 코드를 마음대로 재사용 할 수가 없다.
   - 특별한 메뉴에도 중복되는 코드를 적용시키고 싶다.
- `예예치킨` 클래스의 코드를 마음대로 바꿀 수 없다.
   - 상속을 하는 코드를 변경했을 때 다른 치킨들에게 원치않는 영향을 끼칠 수 있다.

<br><br>

### **3단계: 전략 패턴을 적용해보자.**
자, 여기서 옆 **가게 먐스터치 사장님** 이 전략 패턴을 들고 멋있게 등장한다. <br>
먐스터치 사장님은 상속투성이인 예예치킨사장님의 메뉴를 보고 이렇게 말씀하셨다.

> 일단 상속은 버리자. 그 다음에 변화 될 부분을 따로 모아보고 그 부분을 인터페이스로 관리해보는건 어떨까?

> 변화 될 부분은 튀기고, 굽고, 삶는 부분이군.이 행동들만 전략적으로 관리해보자고. 아래와 같이 말이야!

```java
public interface Cookable {
	public void cook();
}

///
public class FryCooking implements Cookable{
	@Override
	public void cook() {
		System.out.println("튀기는 중");
	}
}
//
public class BakeCooking implements Cookable{
	@Override
	public void cook() {
		System.out.println("굽는 중");
	}
}
//
public class BoildCooking implements Cookable{
	@Override
	public void cook() {
		System.out.println("삶는 중");
	}
}
```

> 그리고 기존의 예예치킨 클래스는 아직 정해지지않은 요리행동을 추상적으로 정의해두는거지. 이 클래스를 구현할 클래스에게 행동을 맡기는거라고!

```java
public abstract class 예예치킨 {
	Cookable cook;
	
  public abstract void 요리한다();

	public void 양념한다() {
		System.out.println("양념하는 중");
	}
	
	public void 포장한다() {
    System.out.println("포장하는 중");
	}
}

```

> 자, 이렇게 되면 예예치킨 클래스를 구현하는 메뉴들은 인터페이스를 이용해서 요리하는 행동을 자유롭게 정의할 수 있게된다고!

```java
public class 구운예예치킨  extends 예예치킨 {
	
	public MallardDuck() {
		cook = new BakingCook();
	}
	
	public void 양념한다() {
		System.out.println("양념하는 중");
	}
	
	public void 포장한다() {
    System.out.println("포장하는 중");
	}
}
```


## 스트래티지 패턴의 장단점

## 스트래티지 패턴에 녹아있는 객체지향
**OCP**

## 어떨 때 사용할까?