# 힙 정렬(Heap Sort)
힙(Heap)의 특성을 이용한 정렬

# 힙(Heap)이 뭔데?

## 힙(Heap)이란?
- 완전 이진 트리(Complete binary tree)에 가까운 형태
    - `트리`: 부모노드와 자식노드로 구성되어진 그래프로 데이터가 서로 연결되어있는 구조
    - `이진 트리`: 각 노드의 자식수가 2 이하인 경우
    - `완전 이진 트리`: Root노드부터 Leaf 노드까지 빠짐없이 채워져 있는 트리
    - **정리하자면, 각 노드의 자식수가 2이하이면서 왼쪽부분까지 꽉 찬 트리**
        - `왼쪽부분` : 노드를 배열로 구성할 때는 왼쪽부터 배열로 옮기게 된다. 만약 왼쪽이 비었다면 빈 공간이 배열로 옮겨가게 되므로 왼쪽부분은 꼭 차있어야한다.
- 최솟값이나 최댓값을 빠르게 찾아내기 위하여 완전 이진 트리를 기반으로 하는 트리
## 힙(Heap)의 구조
### 최대힙 특성(Max-Heap Property)
- 부모 노드의 값은 항상 자식 노드의 값보다 크다.
    - 그러므로 Root노드의 값이 가장 크다.
### 최소힙 특성(Min-Heap Property)
- 부모 노드의 값은 항상 자식 노드의 값보다 작다.
    - 그러므로 Root노드의 값이 가장 작다.

### 힙(Heap)의 배열 저장 방식
- Root노드는 배열의 첫번째에 저장
- 자식 노드는 왼쪽부터 차례대로 저장

### 힙(Heap)의 배열 검색 방식
- 부모노드 찾기 : i/2
- 왼쪽자식 찾기 : 2*i
- 오른쪽자식 찾기 : 2*i + 1



## 힙(Heap)구조가 흐트러져버렸을 때!
어떤 한 노드가 힙구성(최대힙,최소힙)을 파괴해버렸을 때 **자식 중에 조건을 만족하는(큰 값, 작은 값) 노드와 값을 바꿔버린다.** <br>
이것이 **`힙 생성 알고리즘(Heapify Algorythm)`** 이다. <br>단, 단 하나의 노드에 대해서만 적용할 수 있다.

# 시간 복잡도
## `O(N * logN)`

힙 생성 알고리즘은 트리의 높이와 같기 때문에 트리의 높이를 구하는 식과 똑같다.

- `노드의 높이?` :
    - 노드의 높이는 현재 노드에서 자식 노드까지 내려갈 때 **`가장 단순하게`** 내려가는 **`가장 긴 경로`** 에서 거쳐야하는 간선의 수를 말한다. <br>
    - **`N * logN`** <br>
    - 병합정렬과 비슷하다.

### 잠깐! 실제로는...
실제로는 `1/2n * logn` 정도면 힙 생성을 할 수 있다. (ex: 높이가 5정도면 두번정도만 힙 생성 알고리즘을 실행시켜도 힙이 완성될 수 있음) <br>
따라서 저 식을 재정의해보면 `O(n)`이 될 수도 있음.

 # 특징
- `O(N * logN)` 을 **보장한다**.
- 병합정렬과 시간복잡도는 같지만 **`별도의 배열`** 이 필요하지 않는다는 점에서 효율적이다.

<br><br><br>

* * *
### 참고
[T아카데미 컴퓨터 알고리즘 기초](https://www.youtube.com/watch?v=ehNVf2Bcm2Q&list=PL9mhQYIlKEhdvKFh-wVpDuihNQv6C1gSy&index=6)
[동빈나 실전 알고리즘 강좌](https://www.youtube.com/watch?v=iyl9bfp_8ag&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=11)


