# 퀵 정렬(Quick Sort)
하나의 큰 문제를 `분할정복(Devide and Conquer)접근법` 을 이용하여 빠르게 정렬하는 정렬법. <br>
`Partitioning`을 이용하여 **특정한 값(Pivot)** 을 기준으로 큰 숫자와 작은 숫자를 나눈다.

# 퀵 정렬 방법

```c
8 3 7 9 5 1 2 4 10 6
```
- 주어진 배열의 제일 앞 `8`이 `특정한 값(Pivot)`이 된다.
- `Pivot(8)`을 기준으로 순서대로 큰 값을 찾고  그리고 정 반대의 순서대로 작은 값을 을 선택한다. 
    - `Pivot`: 8
    - `큰 값`: 9
    - `작은 값`: 6

- **큰 값과 작은 값을 바꾼다**

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9
```

- `Pivot(8)`을 기준으로 순서대로 큰 값을 찾고  그리고 정 반대의 순서대로 작은 값을 을 선택한다. 
    - `Pivot`: 8
    - `큰 값`: 10
    - `작은 값`: 4
- 여기서 `작은 값(4)`의 인덱스가 `큰 값(10)`의 인덱스를 넘어가 버린다.(엇갈린다.)
- 이 경우엔 `작은 값(4)`을 `Pivot(8)`과 바꾼다.

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 

```
- 기존 `Pivot(8)`을 기준으로 왼쪽은 `Pivot(8)` 보다 작은 값이 되고 오른쪽은 `Pivot(8)`보다 큰 값으로 자연스럽게 분할이 된다.

- 이제 `기존 Pivot(8)`을 기준으로 분할 된 두 값들을 다시 분할하기 위하여 각각 맨 앞의 숫자를 `Pivot`으로 둔다.

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 
[4] 3 7 6 5 1 2 _8_ [10] 9 

```
- **정렬된 `8`을 기준으로 왼쪽**
    - `Pivot(4)`을 기준으로 순서대로 큰 값을 찾고 그리고 정 반대의 순서대로 작은 값을 을 선택한다. 
        - `Pivot`: 4
        - `큰 값`: 7
        - `작은 값`: 2
- **큰 값과 작은 값을 바꾼다** 

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 
[4] 3 7 6 5 1 2 _8_ [10] 9 

// 세번째로 바꾼 배열
[4] 3 2 6 5 1 7 _8_ [10] 9 

```
- **정렬된 `8`을 기준으로 왼쪽**
    - `Pivot(4)`을 기준으로 순서대로 큰 값을 찾고 그리고 정 반대의 순서대로 작은 값을 을 선택한다. 
        - `Pivot`: 4
        - `큰 값`: 6
        - `작은 값`: 1
- **큰 값과 작은 값을 바꾼다** 
```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 
[4] 3 7 6 5 1 2 _8_ [10] 9 

// 세번째로 바꾼 배열
[4] 3 2 6 5 1 7 _8_ [10] 9 

// 네번째로 바꾼 배열
[4] 3 2 1 5 6 7 _8_ [10] 9 

```
- **정렬된 `8`을 기준으로 왼쪽**
    - `Pivot(4)`을 기준으로 순서대로 큰 값을 찾고  그리고 정 반대의 순서대로 작은 값을 을 선택한다. 
        - `Pivot`: 4
        - `큰 값`: 5
        - `작은 값`: 1
- 여기서 `작은 값(1)`의 인덱스가 `큰 값(5)`의 인덱스를 넘어가 버린다.(엇갈린다.)
- 이 경우엔 `작은 값(1)`을 `Pivot(4)`과 바꾼다.

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 
[4] 3 7 6 5 1 2 _8_ [10] 9 

// 세번째로 바꾼 배열
[4] 3 2 6 5 1 7 _8_ [10] 9 

// 네번째로 바꾼 배열
[4] 3 2 1 5 6 7 _8_ [10] 9 

// 다섯번째로 바꾼 배열(엇갈렸을 때)
1 3 2 [4] 5 6 7 _8_ [10] 9 
[1] 3 2 _4_ [5] 6 7 _8_ [10] 9 

```

- 이런 식으로 `Pivot`을 기준으로 작은 값과 큰 값을 정렬하다가 엇갈리면 `Pivot`을 바꿔주면서 정렬을 한다.

```c
// 기존 배열
[8] 3 7 9 5 1 2 4 10 6

// 첫번째로 바꾼 배열
[8] 3 7 6 5 1 2 4 10 9

// 두번째로 바꾼 배열 (엇갈렸을 때)
4 3 7 6 5 1 2 [8] 10 9 
[4] 3 7 6 5 1 2 _8_ [10] 9 

// 세번째로 바꾼 배열
[4] 3 2 6 5 1 7 _8_ [10] 9 

// 네번째로 바꾼 배열
[4] 3 2 1 5 6 7 _8_ [10] 9 

// 다섯번째로 바꾼 배열(엇갈렸을 때)
1 3 2 [4] 5 6 7 _8_ [10] 9 
[1] 3 2 _4_ [5] 6 7 _8_ [10] 9 

'''
_1_ _3_ _2_ _4_ _5_ _6_ _7_ _8_ _10_ _9_ 

```
<br><br>


# 시간 복잡도
## `O(N * logN)`
순환호출의 깊이만큼 시간복잡도가 생긴다.

<br>

# 특징
- `O(N * logN)` 을 가지는 다른 알고리즘과 비교하여 속도가 빠르다.
- 기존 데이터를 담을 배열공간이 필요하지 않다.
- **이미 정렬되어있거나 거의 정렬되어있는 경우 `O(N^2)`으로 정말 느리다** (이럴 경우엔 삽입정렬을 사용한다.)

<br>

# 구현

```java
public class QuickSort {
    static int number = 10;
    static int[] arr = new int[]{1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

    static void swap(int[] arr, int idx1, int idx2) {
        int temp = arr[idx1];
        arr[idx1] = arr[idx2];
        arr[idx2] = temp;
    }

    static void quickSort(int[] arr, int left, int right){
        if(arr.length >= 1 ) {
            return;
        }

        int leftCursor = left;
        int rightCursor = right;
        int pivot = arr[(leftCursor + rightCursor) / 2];

        do {
            while (arr[leftCursor] < pivot) leftCursor++;   // pivot 값보다 작은 값을 만날 때 까지 이동
            while (arr[rightCursor] > pivot) rightCursor--;     // pivot 값보다 큰 값을 만날 때 까지 이동
            if(leftCursor <= rightCursor)                       // 왼쪽 커서의 값이 오른쪽 커서의 값보다 크면 교체
                swap(arr, leftCursor++, rightCursor--);
        }while (leftCursor <= rightCursor);   // 엇갈릴 때 까지

        if(left < rightCursor)                  // 엇갈렸을 때: 지금의 왼쪽 인덱스와 지금의 오른쪽 커서 사이의 범위를 다시 재귀
            quickSort(arr, left, rightCursor);
        if(leftCursor < right)                  // 엇갈렸을 때: 지금의 오른쪽 인덱스와 지금의 왼쪽 커서 사이의 그 범위를 다시 재귀
            quickSort(arr, leftCursor, right);

    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 6, 1, 4, 7, 5};
        quickSort(arr, 0, arr.length-1);

        for(int i=0; i < arr.length; i++){
            System.out.println(arr[i]);
        }
    }
}

```
- 재귀를 사용한다.
- `pivot`은 가운데 인덱스부터 시작한다.

### 참고
[T아카데미 컴퓨터 알고리즘 기초]() <br>
[동빈나 실전 알고리즘 강좌](https://www.youtube.com/watch?v=O-O-90zX-U4&list=PLRx0vPvlEmdDHxCvAQS1_6XV4deOwfVrz&index=5)