# 합병정렬(Merge Sort)
합병을 이용한 정렬 알고리즘

<br>

# 무엇을 어떻게 합병하는가
`두 개의 정렬된 배열`을 입력으로 받아서 합병한다.

### Example
```math
배열은 각각 이미 정렬되어있다.
배열1 = <1,5,6,8>
배열2 = <2,4,7,9>
```
- `배열1`과 `배열2`의 첫번째 숫자를 비교하여 정렬한다.
    -  ```math
        배열1 = <5,6,8>
        배열2 = <2,4,7,9>
        출력배열 = <1>
        ```
- `배열1`과 `배열2`의 첫번째 숫자를 비교하여 정렬한다.
    - ```math
        배열1 = <5,6,8>
        배열2 = <4,7,9>
        출력배열 = <1,2>
        ```
- 가장 작은 숫자는 가장 왼쪽에 있으므로 그것들만 비교하며 반복한다.


<br>

# 정렬의 입력값이 평소와는 다르다..!
- 일반적인 정렬의 입력값은 `하나의 배열`이다. <br>
- 그러나 삽입정렬은 `두개의 배열`을 사용한다.

### 왜? 분할정복(Devide and Conquer) 접근법을 이용했기 때문에!
- 크기가 커서 풀기 어려운 하나의 문제를 크기가 작아서 풀기 쉬운 여러개의 문제로 바꾼다.
- 거대한 배열하나를 계속 쪼개서 배열의 아이템이 하나만 남게하여 그것들을 비교하고 합치고 또 그것들을 비교하고 합친다.

```pseudo
MERGE-SORT(A,p,r)
if p<r
    q = |(q+r)/2|
    MERGE-SORT(A,p,q)
    MERGE-SORT(A,q+1,r)
    MERGE(A,p,q,r)
```
- `A` : n개의 숫자가 들어있는 거대한 배열
- `p` : 배열의 첫번째 인덱스(1)
- `r` : 배열의 마지막 인덱스(n)
- `p<r` : 배열에 아이템이 하나가 들어갈 때 까지
- `q = |(q+r)/2|` : p부터 r까지 절반으로 나눈 값 (n/2)
- `MERGE-SORT(A,p,q)` : p부터 q까지 절반으로 나눈 값 (n/2)으로 계속 쪼갬 (재귀)
- `MERGE-SORT(A,q+1,r)` : 앞에서 쪼개던것의 나머지 반쪼가리도 계속 쪼갬 (재귀)
- `MERGE(A,p,q,r)` : 차례대로 합침

<br>

# 시간 복잡도
## `O(N * logN)`
### 설명
- `n`을 두개로 쪼갠다
- `n/2`의 제일 왼쪽부터 `두번` 비교 = `n번 비교`
- `n/2`를 두개로 쪼갠다.
- `n/4`의 제일 왼쪽부터 `네번` 비교 = `n번 비교`
- 반복한다.
- 비교는 `n`번을 벗어나지않는다.

 비교횟수는 `n`번 이다. 하지만! 재귀로 인한 순환호출의 깊이(`logN`)를 고려해야한다.
 - ex.
    - 배열의 길이가 8이라면 순환호출의 깊이는 3이다.
 

 # 특징
 - `O(N * logN)` 을 **보장한다**.
 - 기존 데이터를 담을 배열공간이 필요하다.


<br><br><br>

* * *
### 참고
[T아카데미 컴퓨터 알고리즘 기초](https://youtu.be/1L-gXkWJreA) <br>
[동빈나 실전 알고리즘 강좌](https://youtu.be/ctkuGoJPmAE)